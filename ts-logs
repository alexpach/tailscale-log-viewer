#!/bin/bash

set -euo pipefail

TAILNET="sunflower-labs.com"
OUTPUT_FORMAT="table"
FILTER_TYPE=""
FILTER_NODE=""

show_help() {
    cat << EOF
Usage: $0 [OPTIONS]

Fetch Tailscale network logs with flexible time intervals and formatting.

Time Options (pick one):
    -m, --minutes N         Last N minutes
    -H, --hours N           Last N hours
    -d, --days N            Last N days  
    -S, --since TIMESTAMP   Start time (RFC 3339 format)
    -U, --until TIMESTAMP   End time (RFC 3339 format, requires --since)
        --today             Today's logs
        --yesterday         Yesterday's logs

Output Options:
    -f, --format FORMAT     Output format: table, json, raw, compact, full (default: table)
    -t, --filter-type TYPE  Filter by traffic type: virtual, subnet, exit, physical
    -n, --filter-node ID    Filter by node ID
    -s, --summary          Show summary statistics only

Other Options:
    -T, --tailnet NAME      Tailnet name (default: sunflower-labs.com)
    -h, --help             Show this help

Format Options:
    table    - Formatted table with machine names (default)
    compact  - One line per entry with all fields
    full     - All traffic flows with: start, src-ip, src-port, dst-ip, dst-port, type, proto, txBytes, rxBytes
    json     - Pretty formatted JSON
    raw      - Raw JSON output

Examples:
    $0 -m 30                        # Last 30 minutes in table format
    $0 -H 6 -f compact              # Last 6 hours in compact format  
    $0 -m 15 -f full                # Last 15 minutes with all traffic details
    $0 -d 7 -t exit                 # Last 7 days of exit traffic
    $0 --today -t virtual           # Today's virtual traffic only
    $0 -m 5 -t exit -f full         # Last 5 minutes of exit traffic, full details

EOF
}

get_api_token() {
    if [[ -n "${TAILSCALE_API_TOKEN:-}" ]]; then
        echo "$TAILSCALE_API_TOKEN"
    elif [[ -f "api-token" ]]; then
        cat api-token
    else
        echo "Error: No API token found. Set TAILSCALE_API_TOKEN environment variable or create api-token file." >&2
        exit 1
    fi
}

validate_date() {
    local date_str="$1"
    if ! date -d "$date_str" >/dev/null 2>&1 && ! date -j -f "%Y-%m-%dT%H:%M:%SZ" "$date_str" >/dev/null 2>&1; then
        echo "Error: Invalid date format: $date_str" >&2
        echo "Use RFC 3339 format like: 2025-08-28T00:00:00Z" >&2
        exit 1
    fi
}

format_date_rfc3339() {
    local date_input="$1"
    if command -v gdate >/dev/null 2>&1; then
        gdate -d "$date_input" --iso-8601=seconds | sed 's/+00:00/Z/'
    else
        date -d "$date_input" --iso-8601=seconds 2>/dev/null | sed 's/+00:00/Z/' || \
        date -u -j -f "%Y-%m-%d %H:%M:%S" "$date_input" "+%Y-%m-%dT%H:%M:%SZ" 2>/dev/null
    fi
}


format_json_output() {
    local response="$1"
    if command -v jq >/dev/null 2>&1; then
        echo "$response" | jq '.'
    else
        echo "$response" | python3 -m json.tool 2>/dev/null || echo "$response"
    fi
}

format_table_output() {
    local response="$1"
    local ip_name_mapping="$2"
    if command -v jq >/dev/null 2>&1; then
        echo "Timestamp                Machine Name             Traffic Type    Duration"
        echo "------------------------------------------------------------------------"
        echo "$response" | jq -r '
        .logs[]? // [] | select(.) | 
        . as $log |
        (if .virtualTraffic then "virtual" 
         elif .subnetTraffic then "subnet"
         elif .exitTraffic then "exit"
         elif .physicalTraffic then "physical"
         else "unknown" end) as $traffic_type |
        (if .virtualTraffic then (.virtualTraffic[0].src // .virtualTraffic[0].dst // "unknown")
         elif .subnetTraffic then (.subnetTraffic[0].src // .subnetTraffic[0].dst // "unknown") 
         elif .exitTraffic then (.exitTraffic[0].src // "unknown")
         elif .physicalTraffic then (.physicalTraffic[0].src // .physicalTraffic[0].dst // "unknown")
         else "unknown" end) as $ip_addr |
        "\($log.logged // $log.start) \($ip_addr | split(":")[0]) \($traffic_type) \($log.end // "N/A")"' | \
        while read -r timestamp ip traffic_type duration; do
            local machine_name
            machine_name=$(lookup_machine_name "$ip" "$ip_name_mapping")
            printf "%-24s %-24s %-15s %s\n" "$timestamp" "$machine_name" "$traffic_type" "$duration"
        done
    else
        echo "jq is required for table formatting. Install jq or use --format json"
        exit 1
    fi
}

format_compact_output() {
    local response="$1"
    local ip_name_mapping="$2"
    if command -v jq >/dev/null 2>&1; then
        echo "$response" | jq -r '
        .logs[]? // [] | select(.) | 
        . as $log |
        (if .virtualTraffic then "virtual" 
         elif .subnetTraffic then "subnet"
         elif .exitTraffic then "exit"
         elif .physicalTraffic then "physical"
         else "unknown" end) as $traffic_type |
        (if .virtualTraffic then (.virtualTraffic[0].src // .virtualTraffic[0].dst // "unknown")
         elif .subnetTraffic then (.subnetTraffic[0].src // .subnetTraffic[0].dst // "unknown") 
         elif .exitTraffic then (.exitTraffic[0].src // "unknown")
         elif .physicalTraffic then (.physicalTraffic[0].src // .physicalTraffic[0].dst // "unknown")
         else "unknown" end) as $ip_addr |
        "\($log.logged // $log.start) | \($ip_addr | split(":")[0]) | \($traffic_type) | \($log.end // "N/A") | \(.nodeId // "unknown")"' | \
        while read -r line; do
            timestamp=$(echo "$line" | cut -d'|' -f1 | xargs)
            ip=$(echo "$line" | cut -d'|' -f2 | xargs)
            traffic_type=$(echo "$line" | cut -d'|' -f3 | xargs)
            duration=$(echo "$line" | cut -d'|' -f4 | xargs)
            node_id=$(echo "$line" | cut -d'|' -f5 | xargs)
            
            local machine_name
            machine_name=$(lookup_machine_name "$ip" "$ip_name_mapping")
            
            echo "$timestamp $machine_name $traffic_type $duration $node_id"
        done
    else
        echo "jq is required for compact formatting. Install jq or use --format json"
        exit 1
    fi
}

get_protocol_name() {
    local proto_num="$1"
    if [[ -z "$proto_num" || "$proto_num" == "null" ]]; then
        echo ""
        return
    fi
    case "$proto_num" in
        1) echo "ICMP" ;;
        6) echo "TCP" ;;
        17) echo "UDP" ;;
        47) echo "GRE" ;;
        50) echo "ESP" ;;
        51) echo "AH" ;;
        *) echo "$proto_num" ;;
    esac
}

get_service_name() {
    local port="$1"
    if [[ -z "$port" || "$port" == "null" || "$port" == "0" ]]; then
        echo ""
        return
    fi
    case "$port" in
        20) echo "ftpd" ;;
        21) echo "ftp" ;;
        22) echo "ssh" ;;
        23) echo "telnt" ;;
        25) echo "smtp" ;;
        53) echo "dns" ;;
        67) echo "dhcps" ;;
        68) echo "dhcpc" ;;
        80) echo "http" ;;
        110) echo "pop3" ;;
        123) echo "ntp" ;;
        137) echo "nbns" ;;
        138) echo "nbdgm" ;;
        139) echo "nbssn" ;;
        143) echo "imap" ;;
        161) echo "snmp" ;;
        162) echo "snmpt" ;;
        443) echo "https" ;;
        465) echo "smtps" ;;
        587) echo "subm" ;;
        993) echo "imaps" ;;
        995) echo "pop3s" ;;
        3389) echo "rdp" ;;
        5432) echo "pgsql" ;;
        3306) echo "mysql" ;;
        6379) echo "redis" ;;
        8080) echo "http8" ;;
        9100) echo "prom" ;;
        *) echo "$port" ;;
    esac
}

format_timestamp() {
    local timestamp="$1"
    if [[ -z "$timestamp" || "$timestamp" == "null" ]]; then
        echo ""
        return
    fi
    
    # Remove milliseconds and convert to local time
    local clean_timestamp=$(echo "$timestamp" | sed 's/\.[0-9]*Z$/Z/')
    
    # Convert to local time format (HH:MM:SS)
    if command -v gdate >/dev/null 2>&1; then
        gdate -d "$clean_timestamp" +"%H:%M:%S" 2>/dev/null || echo "$clean_timestamp"
    else
        date -d "$clean_timestamp" +"%H:%M:%S" 2>/dev/null || \
        date -j -f "%Y-%m-%dT%H:%M:%SZ" "$clean_timestamp" +"%H:%M:%S" 2>/dev/null || \
        echo "$clean_timestamp"
    fi
}

format_full_output() {
    local response="$1"
    local ip_name_mapping="$2"
    if command -v jq >/dev/null 2>&1; then
        echo "Time     Src IP               SPort    Dst IP               DPort    Type     Proto TxBytes  RxBytes"
        echo "----------------------------------------------------------------------------------------------------"
        
        # Build the jq filter based on FILTER_TYPE
        local jq_filter='
        .logs[]? // [] | select(.) | 
        . as $log |
        ('
        
        if [[ -n "$FILTER_TYPE" ]]; then
            case "$FILTER_TYPE" in
                "virtual")
                    jq_filter+='
                    if .virtualTraffic then 
                        .virtualTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "virtual", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
                    else [] end'
                    ;;
                "subnet")
                    jq_filter+='
                    if .subnetTraffic then 
                        .subnetTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "subnet", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
                    else [] end'
                    ;;
                "exit")
                    jq_filter+='
                    if .exitTraffic then 
                        .exitTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "exit", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
                    else [] end'
                    ;;
                "physical")
                    jq_filter+='
                    if .physicalTraffic then 
                        .physicalTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "physical", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
                    else [] end'
                    ;;
            esac
        else
            # No filter - show all traffic types
            jq_filter+='
            if .virtualTraffic then 
                .virtualTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "virtual", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
            else [] end,
            if .subnetTraffic then 
                .subnetTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "subnet", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
            else [] end,
            if .exitTraffic then 
                .exitTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "exit", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
            else [] end,
            if .physicalTraffic then 
                .physicalTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "physical", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
            else [] end'
        fi
        
        jq_filter+='
        ) | select(length > 0) | @tsv'
        
        echo "$response" | jq -r "$jq_filter" | \
        while IFS=$'\t' read -r start src dst type proto txBytes rxBytes; do
            # Format timestamp to local time
            formatted_time=$(format_timestamp "$start")
            
            # Handle empty fields - convert NULL placeholders to empty strings
            [[ "$src" == "NULL" || "$src" == "null" || -z "$src" ]] && src=""
            [[ "$dst" == "NULL" || "$dst" == "null" || -z "$dst" ]] && dst=""
            [[ "$proto" == "NULL" || "$proto" == "null" || -z "$proto" ]] && proto=""
            [[ "$txBytes" == "NULL" || "$txBytes" == "null" || -z "$txBytes" ]] && txBytes=""
            [[ "$rxBytes" == "NULL" || "$rxBytes" == "null" || -z "$rxBytes" ]] && rxBytes=""
            
            # Split src into IP and port
            if [[ -n "$src" ]]; then
                src_ip="${src%:*}"
                src_port="${src##*:}"
                if [[ "$src_ip" == "$src_port" ]]; then
                    # No port separator found
                    src_port=""
                fi
            else
                src_ip=""
                src_port=""
            fi
            
            # Split dst into IP and port
            if [[ -n "$dst" ]]; then
                dst_ip="${dst%:*}"
                dst_port="${dst##*:}"
                if [[ "$dst_ip" == "$dst_port" ]]; then
                    # No port separator found
                    dst_port=""
                fi
            else
                dst_ip=""
                dst_port=""
            fi
            
            # Resolve Tailscale IPs (100.x.x.x) to machine names
            if [[ "$src_ip" =~ ^100\. ]]; then
                resolved_name=$(lookup_machine_name "$src_ip" "$ip_name_mapping")
                if [[ "$resolved_name" != "$src_ip" ]]; then
                    src_ip="$resolved_name"
                fi
            fi
            
            if [[ "$dst_ip" =~ ^100\. ]]; then
                resolved_name=$(lookup_machine_name "$dst_ip" "$ip_name_mapping")
                if [[ "$resolved_name" != "$dst_ip" ]]; then
                    dst_ip="$resolved_name"
                fi
            fi
            
            # Convert port numbers to service names
            src_service=$(get_service_name "$src_port")
            dst_service=$(get_service_name "$dst_port")
            
            # Use service names if available, otherwise use port numbers
            [[ -n "$src_service" && "$src_service" != "$src_port" ]] && src_port="$src_service"
            [[ -n "$dst_service" && "$dst_service" != "$dst_port" ]] && dst_port="$dst_service"
            
            # Convert protocol number to name
            proto_name=$(get_protocol_name "$proto")
            
            # Format with proper column alignment
            printf "%-8s %-20s %-8s %-20s %-8s %-8s %-5s %-8s %s\n" \
                "$formatted_time" "$src_ip" "$src_port" "$dst_ip" "$dst_port" "$type" "$proto_name" "$txBytes" "$rxBytes"
        done
    else
        echo "jq is required for full formatting. Install jq or use --format json"
        exit 1
    fi
}

show_summary() {
    local response="$1"
    if command -v jq >/dev/null 2>&1; then
        local total_logs=$(echo "$response" | jq -r '.logs | length')
        local unique_nodes=$(echo "$response" | jq -r '[.logs[]?.nodeId] | unique | length')
        local traffic_types=$(echo "$response" | jq -r '[.logs[] | keys[] | select(. | contains("Traffic"))] | unique | join(", ")')
        
        echo "=== Summary ==="
        echo "Total log entries: $total_logs"
        echo "Unique nodes: $unique_nodes"
        echo "Traffic types found: ${traffic_types:-none}"
        
        if [[ $total_logs -gt 0 ]]; then
            echo ""
            echo "Nodes breakdown:"
            echo "$response" | jq -r '.logs[]?.nodeId' | sort | uniq -c | sort -nr | while read -r count node; do
                printf "  %-32s: %s entries\n" "$node" "$count"
            done
        fi
    else
        echo "jq is required for summary. Install jq or use --format json"
        exit 1
    fi
}

filter_logs() {
    local response="$1"
    local filtered="$response"
    
    if [[ -n "$FILTER_TYPE" ]] && command -v jq >/dev/null 2>&1; then
        filtered=$(echo "$filtered" | jq --arg type "$FILTER_TYPE" '.logs |= map(select(.[$type + "Traffic"] != null))')
    fi
    
    if [[ -n "$FILTER_NODE" ]] && command -v jq >/dev/null 2>&1; then
        filtered=$(echo "$filtered" | jq --arg node "$FILTER_NODE" '.logs |= map(select(.nodeId == $node))')
    fi
    
    echo "$filtered"
}

fetch_devices() {
    local api_token
    api_token=$(get_api_token)
    
    local url="https://api.tailscale.com/api/v2/tailnet/${TAILNET}/devices"
    
    echo "Fetching device information..." >&2
    
    local response
    response=$(curl -s -u "$api_token:" "$url")
    local curl_exit=$?
    
    if [[ $curl_exit -ne 0 ]]; then
        echo "Error: Failed to fetch devices from Tailscale API (curl exit code: $curl_exit)" >&2
        exit 1
    fi
    
    if echo "$response" | grep -q '"error"'; then
        echo "Error from Tailscale API:" >&2
        echo "$response" >&2
        exit 1
    fi
    
    echo "$response"
}

create_ip_name_mapping() {
    local devices_response="$1"
    if command -v jq >/dev/null 2>&1; then
        echo "$devices_response" | jq -r '.devices[] | "\(.addresses[0] // "unknown") \(.name // .hostname // "unknown")"' | \
        while read -r ip name; do
            echo "$ip:$name"
        done
    fi
}

lookup_machine_name() {
    local ip="$1"
    local mapping="$2"
    
    local name=$(echo "$mapping" | grep "^$ip:" | cut -d: -f2-)
    if [[ -n "$name" && "$name" != "unknown" ]]; then
        # Strip the tailnet suffix (e.g., .tail43508.ts.net)
        echo "$name" | sed 's/\.tail[0-9]*\.ts\.net$//'
    else
        echo "$ip"
    fi
}

fetch_logs() {
    local api_token
    api_token=$(get_api_token)
    
    local url="https://api.tailscale.com/api/v2/tailnet/${TAILNET}/logging/network?start=${START_TIME}&end=${END_TIME}"
    
    echo "Fetching logs from $START_TIME to $END_TIME..." >&2
    
    local response
    response=$(curl -s -u "$api_token:" "$url")
    local curl_exit=$?
    
    if [[ $curl_exit -ne 0 ]]; then
        echo "Error: Failed to fetch logs from Tailscale API (curl exit code: $curl_exit)" >&2
        exit 1
    fi
    
    if echo "$response" | grep -q '"error"'; then
        echo "Error from Tailscale API:" >&2
        echo "$response" >&2
        exit 1
    fi
    
    echo "$response"
}

main() {
    local show_summary=false
    local hours=""
    local days=""
    local minutes=""
    local since=""
    local until=""
    local today=false
    local yesterday=false
    
    # If no arguments provided, show help
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_help
                exit 0
                ;;
            --format|-f)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            --filter-type|-t)
                case "$2" in
                    virtual|subnet|exit|physical)
                        FILTER_TYPE="$2"
                        ;;
                    table|json|raw|compact|full)
                        echo "Error: '$2' is an output format, not a traffic type." >&2
                        echo "Use: -f $2 (for format) instead of -t $2" >&2
                        echo "Valid traffic types for -t: virtual, subnet, exit, physical" >&2
                        exit 1
                        ;;
                    *)
                        echo "Error: Invalid traffic type '$2'" >&2
                        echo "Valid traffic types: virtual, subnet, exit, physical" >&2
                        exit 1
                        ;;
                esac
                shift 2
                ;;
            --filter-node|-n)
                FILTER_NODE="$2"
                shift 2
                ;;
            --tailnet|-T)
                TAILNET="$2"
                shift 2
                ;;
            --summary|-s)
                show_summary=true
                shift
                ;;
            --hours|-H)
                hours="$2"
                shift 2
                ;;
            --days|-d)
                days="$2"
                shift 2
                ;;
            --minutes|-m)
                minutes="$2"
                shift 2
                ;;
            --since|-S)
                since="$2"
                shift 2
                ;;
            --until|-U)
                until="$2"
                shift 2
                ;;
            --today)
                today=true
                shift
                ;;
            --yesterday)
                yesterday=true
                shift
                ;;
            *)
                echo "Error: Unknown option $1" >&2
                show_help >&2
                exit 1
                ;;
        esac
    done
    
    # Set time range based on parsed arguments
    if [[ -n "$minutes" ]]; then
        if command -v gdate >/dev/null 2>&1; then
            START_TIME=$(gdate -u -d "$minutes minutes ago" --iso-8601=seconds | sed 's/+00:00/Z/')
            END_TIME=$(gdate -u --iso-8601=seconds | sed 's/+00:00/Z/')
        else
            START_TIME=$(date -u -d "$minutes minutes ago" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-${minutes}M +"%Y-%m-%dT%H:%M:%SZ")
            END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        fi
    elif [[ -n "$hours" ]]; then
        if command -v gdate >/dev/null 2>&1; then
            START_TIME=$(gdate -u -d "$hours hours ago" --iso-8601=seconds | sed 's/+00:00/Z/')
            END_TIME=$(gdate -u --iso-8601=seconds | sed 's/+00:00/Z/')
        else
            START_TIME=$(date -u -d "$hours hours ago" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-${hours}H +"%Y-%m-%dT%H:%M:%SZ")
            END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        fi
    elif [[ -n "$days" ]]; then
        if command -v gdate >/dev/null 2>&1; then
            START_TIME=$(gdate -u -d "$days days ago" --iso-8601=seconds | sed 's/+00:00/Z/')
            END_TIME=$(gdate -u --iso-8601=seconds | sed 's/+00:00/Z/')
        else
            START_TIME=$(date -u -d "$days days ago" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-${days}d +"%Y-%m-%dT%H:%M:%SZ")
            END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        fi
    elif [[ "$today" == true ]]; then
        if command -v gdate >/dev/null 2>&1; then
            START_TIME=$(gdate -u -d "today 00:00:00" --iso-8601=seconds | sed 's/+00:00/Z/')
            END_TIME=$(gdate -u --iso-8601=seconds | sed 's/+00:00/Z/')
        else
            START_TIME=$(date -u -d "today 00:00:00" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u +"%Y-%m-%dT00:00:00Z")
            END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        fi
    elif [[ "$yesterday" == true ]]; then
        if command -v gdate >/dev/null 2>&1; then
            START_TIME=$(gdate -u -d "yesterday 00:00:00" --iso-8601=seconds | sed 's/+00:00/Z/')
            END_TIME=$(gdate -u -d "yesterday 23:59:59" --iso-8601=seconds | sed 's/+00:00/Z/')
        else
            START_TIME=$(date -u -d "yesterday 00:00:00" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-1d +"%Y-%m-%dT00:00:00Z")
            END_TIME=$(date -u -d "yesterday 23:59:59" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-1d +"%Y-%m-%dT23:59:59Z")
        fi
    elif [[ -n "$since" ]]; then
        validate_date "$since"
        START_TIME="$since"
        if [[ -n "$until" ]]; then
            validate_date "$until"
            END_TIME="$until"
        else
            if command -v gdate >/dev/null 2>&1; then
                END_TIME=$(gdate -u --iso-8601=seconds | sed 's/+00:00/Z/')
            else
                END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            fi
        fi
    else
        echo "Error: You must specify a time range option (--minutes, --hours, --days, --today, --yesterday, or --since)" >&2
        show_help >&2
        exit 1
    fi
    
    if [[ "$OUTPUT_FORMAT" != "json" && "$OUTPUT_FORMAT" != "table" && "$OUTPUT_FORMAT" != "raw" && "$OUTPUT_FORMAT" != "compact" && "$OUTPUT_FORMAT" != "full" ]]; then
        echo "Error: Invalid output format. Use: json, table, raw, compact, or full" >&2
        exit 1
    fi
    
    # Fetch device information for machine name mapping (for table, compact, and full formats)
    local ip_name_mapping=""
    if [[ "$OUTPUT_FORMAT" == "table" || "$OUTPUT_FORMAT" == "compact" || "$OUTPUT_FORMAT" == "full" ]]; then
        local devices_response
        devices_response=$(fetch_devices)
        ip_name_mapping=$(create_ip_name_mapping "$devices_response")
    fi
    
    local response
    response=$(fetch_logs)
    
    local filtered_response
    # Don't apply log-level filtering for full format since it handles filtering internally
    if [[ "$OUTPUT_FORMAT" == "full" ]]; then
        filtered_response="$response"
    else
        filtered_response=$(filter_logs "$response")
    fi
    
    if [[ "$show_summary" == true ]]; then
        show_summary "$filtered_response"
    elif [[ "$OUTPUT_FORMAT" == "table" ]]; then
        format_table_output "$filtered_response" "$ip_name_mapping"
    elif [[ "$OUTPUT_FORMAT" == "compact" ]]; then
        format_compact_output "$filtered_response" "$ip_name_mapping"
    elif [[ "$OUTPUT_FORMAT" == "full" ]]; then
        format_full_output "$filtered_response" "$ip_name_mapping"
    elif [[ "$OUTPUT_FORMAT" == "json" ]]; then
        format_json_output "$filtered_response"
    else
        echo "$filtered_response"
    fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
