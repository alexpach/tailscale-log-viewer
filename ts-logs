#!/bin/bash

set -euo pipefail

# Signal handling for clean shutdown
cleanup() {
    local exit_code=$?
    if [[ "$DEBUG_MODE" == true ]]; then
        debug_log "Script interrupted. Cleaning up..."
    fi
    
    # Only show statistics on interrupt/signal, not normal exit
    # Normal exit will show stats in main()
    if [[ $exit_code -ne 0 ]] && [[ "$SHOW_STATS" == true ]] && [[ -n "$PROCESSING_START_TIME" ]]; then
        show_statistics
    fi
    
    exit $exit_code
}

trap cleanup SIGINT SIGTERM EXIT

# Debug logging function
debug_log() {
    if [[ "$DEBUG_MODE" == true ]]; then
        echo "[DEBUG $(date '+%H:%M:%S')] $*" >&2
    fi
}

# Load environment variables from .env file if it exists
if [[ -f .env ]]; then
    # shellcheck disable=SC1091
    source .env
fi

# Default values (can be overridden by .env or command line)
TAILNET="${TAILNET:-your-tailnet.com}"
OUTPUT_FORMAT="table"
FILTER_TYPE=""
FILTER_SRC=""
FILTER_DST=""
EXCLUDE_SRC=""
EXCLUDE_DST=""
DEBUG_MODE=false
SHOW_STATS=false
MASK_IPS=false
API_FETCH_TIME=0
DEVICE_FETCH_TIME=0
TOTAL_RECORDS=0
FILTERED_RECORDS=0
EXCLUDED_RECORDS=0
PROCESSING_START_TIME=""
PROCESSING_END_TIME=""

show_help() {
    cat << EOF
Usage: $0 [OPTIONS]

Fetch Tailscale network logs with flexible time intervals and formatting.

Time Options (pick one):
    -m, --minutes N         Last N minutes
    -H, --hours N           Last N hours
    -d, --days N            Last N days  
        --since TIMESTAMP   Start time (RFC 3339 format)
        --until TIMESTAMP   End time (RFC 3339 format, requires --since)
        --today             Today's logs
        --yesterday         Yesterday's logs

Output Options:
    -f, --format FORMAT     Output format: table, json, raw, compact, csv (default: table)
    -t, --filter-type TYPE  Filter by traffic type: virtual, subnet, exit, physical
    -S, --src FILTER        Filter by source (machine name, IP, or node ID)
    -D, --dst FILTER        Filter by destination (machine name, IP, or node ID)
    -s, --summary           Show summary statistics only

Other Options:
    -T, --tailnet NAME      Tailnet name (default: your-tailnet.com)
        --exclude-src FILTER Exclude source traffic (machine name, IP, or node ID)
        --exclude-dst FILTER Exclude destination traffic (machine name, IP, or node ID)
        --mask-ips           Mask IP addresses for privacy (shows first 2 octets only)
        --debug              Enable debug mode for verbose output
        --stats              Show processing statistics
    -h, --help              Show this help

Format Options:
    table    - All traffic flows with: time, src-ip, src-port, dst-ip, dst-port, type, proto, txBytes, rxBytes (default)
    compact  - Simplified view: time, src-ip, dst-ip, type
    csv      - Comma-separated values for spreadsheet import
    json     - Pretty formatted JSON
    raw      - Raw JSON output

Examples:
    $0 -m 30                            # Last 30 minutes in table format
    $0 -H 6 -f compact                  # Last 6 hours in compact format  
    $0 -m 15                            # Last 15 minutes with all traffic details
    $0 -d 7 -t exit                     # Last 7 days of exit traffic
    $0 --today -t virtual               # Today's virtual traffic only
    $0 -m 5 -t exit -f compact          # Last 5 minutes of exit traffic, simplified view
    $0 -H 2 -S laptop-work              # Last 2 hours from source 'laptop-work'
    $0 -m 10 -D 100.64.0.1              # Last 10 minutes to destination IP
    $0 -H 1 -S server -D 192.168.1      # Last hour from 'server' to '192.168.1' subnet
    $0 -d 1 -f csv > traffic.csv        # Export last day's traffic to CSV file

EOF
}

check_configuration() {
    # Check if tailnet is still the default placeholder
    if [[ "$TAILNET" == "your-tailnet.com" || "$TAILNET" == "your-tailnet-here.com" ]]; then
        echo "Error: Tailnet not configured." >&2
        echo "" >&2
        echo "To fix this:" >&2
        echo "1. Find your tailnet name at: https://login.tailscale.com/admin/settings/general" >&2
        echo "2. Either:" >&2
        echo "   - Copy .env.example to .env and set TAILNET=your-actual-tailnet.com" >&2
        echo "   - Use command line: $0 -T your-actual-tailnet.com [other options]" >&2
        echo "   - Set environment variable: export TAILNET='your-actual-tailnet.com'" >&2
        exit 1
    fi
}

get_api_token() {
    if [[ -n "${TAILSCALE_API_TOKEN:-}" ]]; then
        echo "$TAILSCALE_API_TOKEN"
    elif [[ -f "api-token" ]]; then
        cat api-token
    else
        echo "Error: No Tailscale API token found." >&2
        echo "" >&2
        echo "To fix this, you need to:" >&2
        echo "1. Get an API token from: https://login.tailscale.com/admin/settings/keys" >&2
        echo "2. Click 'Generate API key' and set permissions: logs:network:read and devices:read" >&2
        echo "3. Either:" >&2
        echo "   - Copy .env.example to .env and add your token there (recommended)" >&2
        echo "   - Set environment variable: export TAILSCALE_API_TOKEN='your-token'" >&2
        echo "   - Or create an 'api-token' file with your token" >&2
        exit 1
    fi
}

validate_date() {
    local date_str="$1"
    if ! date -d "$date_str" >/dev/null 2>&1 && ! date -j -f "%Y-%m-%dT%H:%M:%SZ" "$date_str" >/dev/null 2>&1; then
        echo "Error: Invalid date format: $date_str" >&2
        echo "Use RFC 3339 format like: 2025-08-28T00:00:00Z" >&2
        exit 1
    fi
}

validate_numeric() {
    local value="$1"
    local param_name="$2"
    
    # Check if value is empty
    if [[ -z "$value" ]]; then
        echo "Error: Invalid value for $param_name: empty value" >&2
        echo "Value must be a positive integer (1 or greater)" >&2
        exit 1
    fi
    
    # Check if value is a positive integer (no leading zeros, starts with 1-9)
    if ! [[ "$value" =~ ^[1-9][0-9]*$ ]]; then
        echo "Error: Invalid value for $param_name: '$value'" >&2
        echo "Value must be a positive integer (1 or greater)" >&2
        exit 1
    fi
}

# Consolidated date handling functions
get_date_command() {
    if command -v gdate >/dev/null 2>&1; then
        echo "gdate"
    else
        echo "date"
    fi
}

format_date_relative() {
    local amount="$1"
    local unit="$2"  # minutes, hours, days
    local date_cmd=$(get_date_command)
    
    if [[ "$date_cmd" == "gdate" ]]; then
        $date_cmd -u -d "$amount $unit ago" --iso-8601=seconds | sed 's/+00:00/Z/'
    else
        case "$unit" in
            minutes) date -u -d "$amount minutes ago" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-"${amount}"M +"%Y-%m-%dT%H:%M:%SZ" ;;
            hours) date -u -d "$amount hours ago" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-"${amount}"H +"%Y-%m-%dT%H:%M:%SZ" ;;
            days) date -u -d "$amount days ago" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-"${amount}"d +"%Y-%m-%dT%H:%M:%SZ" ;;
        esac
    fi
}

format_date_current() {
    local date_cmd=$(get_date_command)
    if [[ "$date_cmd" == "gdate" ]]; then
        $date_cmd -u --iso-8601=seconds | sed 's/+00:00/Z/'
    else
        date -u +"%Y-%m-%dT%H:%M:%SZ"
    fi
}

format_date_rfc3339() {
    local date_input="$1"
    local date_cmd=$(get_date_command)
    if [[ "$date_cmd" == "gdate" ]]; then
        $date_cmd -d "$date_input" --iso-8601=seconds | sed 's/+00:00/Z/'
    else
        date -d "$date_input" --iso-8601=seconds 2>/dev/null | sed 's/+00:00/Z/' || \
        date -u -j -f "%Y-%m-%d %H:%M:%S" "$date_input" "+%Y-%m-%dT%H:%M:%SZ" 2>/dev/null
    fi
}

# Function to mask IP addresses for privacy
mask_ip() {
    local ip="$1"
    if [[ "$MASK_IPS" != true ]]; then
        echo "$ip"
        return
    fi
    
    # Check if it's an IPv6 address
    if [[ "$ip" =~ : ]]; then
        # IPv6: Show first 4 segments
        echo "${ip%%:*:*:*:*}:xxxx:xxxx:xxxx:xxxx"
    elif [[ "$ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        # IPv4: Show first 2 octets
        local octet1=$(echo "$ip" | cut -d. -f1)
        local octet2=$(echo "$ip" | cut -d. -f2)
        echo "${octet1}.${octet2}.xxx.xxx"
    else
        # Not an IP, return as-is (might be a hostname)
        echo "$ip"
    fi
}

# Function to check if traffic should be excluded
should_exclude() {
    local src="$1"
    local dst="$2"
    local ip_name_mapping="$3"
    
    # Check source exclusion
    if [[ -n "$EXCLUDE_SRC" ]]; then
        local resolved_src_ip=$(resolve_machine_name_to_ip "$EXCLUDE_SRC" "$ip_name_mapping")
        
        if [[ "$src" == *"$EXCLUDE_SRC"* ]]; then
            ((EXCLUDED_RECORDS++))
            return 0  # Should exclude
        elif [[ -n "$resolved_src_ip" ]] && [[ "$src" == *"$resolved_src_ip"* ]]; then
            ((EXCLUDED_RECORDS++))
            return 0  # Should exclude
        fi
    fi
    
    # Check destination exclusion
    if [[ -n "$EXCLUDE_DST" ]]; then
        local resolved_dst_ip=$(resolve_machine_name_to_ip "$EXCLUDE_DST" "$ip_name_mapping")
        
        if [[ "$dst" == *"$EXCLUDE_DST"* ]]; then
            ((EXCLUDED_RECORDS++))
            return 0  # Should exclude
        elif [[ -n "$resolved_dst_ip" ]] && [[ "$dst" == *"$resolved_dst_ip"* ]]; then
            ((EXCLUDED_RECORDS++))
            return 0  # Should exclude
        fi
    fi
    
    return 1  # Don't exclude
}

# Function to show processing statistics
show_statistics() {
    if [[ "$SHOW_STATS" != true ]]; then
        return
    fi
    
    echo "" >&2
    echo "=== Processing Statistics ===" >&2
    echo "API Fetch Time: ${API_FETCH_TIME}ms" >&2
    echo "Device Fetch Time: ${DEVICE_FETCH_TIME}ms" >&2
    echo "Total Records Fetched: $TOTAL_RECORDS" >&2
    echo "Records After Filtering: $FILTERED_RECORDS" >&2
    echo "Records Excluded: $EXCLUDED_RECORDS" >&2
    
    if [[ -n "$PROCESSING_START_TIME" ]] && [[ -n "$PROCESSING_END_TIME" ]]; then
        local processing_time=$((PROCESSING_END_TIME - PROCESSING_START_TIME))
        echo "Total Processing Time: ${processing_time}ms" >&2
    fi
    
    echo "Time Range: $START_TIME to $END_TIME" >&2
    
    if [[ -n "$FILTER_TYPE" ]]; then
        echo "Traffic Type Filter: $FILTER_TYPE" >&2
    fi
    
    if [[ -n "$FILTER_SRC" ]]; then
        echo "Source Filter: $FILTER_SRC" >&2
    fi
    
    if [[ -n "$FILTER_DST" ]]; then
        echo "Destination Filter: $FILTER_DST" >&2
    fi
    
    if [[ -n "$EXCLUDE_SRC" ]]; then
        echo "Source Exclusion: $EXCLUDE_SRC" >&2
    fi
    
    if [[ -n "$EXCLUDE_DST" ]]; then
        echo "Destination Exclusion: $EXCLUDE_DST" >&2
    fi
    
    echo "===========================" >&2
}


format_json_output() {
    local response="$1"
    if command -v jq >/dev/null 2>&1; then
        echo "$response" | jq '.'
    else
        echo "$response" | python3 -m json.tool 2>/dev/null || echo "$response"
    fi
}


format_compact_output() {
    local response="$1"
    local ip_name_mapping="$2"
    if command -v jq >/dev/null 2>&1; then
        show_filtering_info "$ip_name_mapping"
        echo "Time     Src IP                                      Dst IP                                      Type"
        echo "--------|-------------------------------------------|-------------------------------------------|--------"
        
        # Check if there are any logs at all
        local log_count=$(echo "$response" | jq -r '.logs | length // 0' 2>/dev/null || echo "0")
        if [[ "$log_count" -eq 0 ]]; then
            echo "No logs captured for this time range"
            return
        fi
        
        # Build the jq filter based on FILTER_TYPE
        local jq_filter='
        .logs[]? // [] | select(.) | 
        . as $log |
        ('
        
        if [[ -n "$FILTER_TYPE" ]]; then
            case "$FILTER_TYPE" in
                "virtual")
                    jq_filter+='
                    if .virtualTraffic then 
                        .virtualTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "virtual"]
                    else [] end'
                    ;;
                "subnet")
                    jq_filter+='
                    if .subnetTraffic then 
                        .subnetTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "subnet"]
                    else [] end'
                    ;;
                "exit")
                    jq_filter+='
                    if .exitTraffic then 
                        .exitTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "exit"]
                    else [] end'
                    ;;
                "physical")
                    jq_filter+='
                    if .physicalTraffic then 
                        .physicalTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "physical"]
                    else [] end'
                    ;;
            esac
        else
            # No filter - show all traffic types
            jq_filter+='
            if .virtualTraffic then 
                .virtualTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "virtual"]
            else [] end,
            if .subnetTraffic then 
                .subnetTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "subnet"]
            else [] end,
            if .exitTraffic then 
                .exitTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "exit"]
            else [] end,
            if .physicalTraffic then 
                .physicalTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "physical"]
            else [] end'
        fi
        
        jq_filter+='
        ) | select(length > 0) | @tsv'
        
        # Process all flows and stream output while counting lines
        local line_count=0
        
        while IFS=$'\t' read -r start src dst type; do
            # Format timestamp to local time
            formatted_time=$(format_timestamp "$start")
            
            # Handle empty fields - convert NULL placeholders to empty strings
            [[ "$src" == "NULL" || "$src" == "null" || -z "$src" ]] && src=""
            [[ "$dst" == "NULL" || "$dst" == "null" || -z "$dst" ]] && dst=""
            
            # Split src into IP and port (handle IPv6 [ip]:port format)
            if [[ -n "$src" ]]; then
                if [[ "$src" =~ ^\[.*\]:[0-9]+$ ]]; then
                    # IPv6 format: [ipv6]:port
                    src_ip="${src%:*}"
                    src_port="${src##*:}"
                elif [[ "$src" =~ ^[^:]*:[0-9]+$ ]]; then
                    # IPv4 format: ipv4:port
                    src_ip="${src%:*}"
                    src_port="${src##*:}"
                else
                    # No port or IPv6 without port
                    src_ip="$src"
                    src_port=""
                fi
            else
                src_ip=""
                src_port=""
            fi
            
            # Split dst into IP and port (handle IPv6 [ip]:port format)
            if [[ -n "$dst" ]]; then
                if [[ "$dst" =~ ^\[.*\]:[0-9]+$ ]]; then
                    # IPv6 format: [ipv6]:port
                    dst_ip="${dst%:*}"
                    dst_port="${dst##*:}"
                elif [[ "$dst" =~ ^[^:]*:[0-9]+$ ]]; then
                    # IPv4 format: ipv4:port
                    dst_ip="${dst%:*}"
                    dst_port="${dst##*:}"
                else
                    # No port or IPv6 without port
                    dst_ip="$dst"
                    dst_port=""
                fi
            else
                dst_ip=""
                dst_port=""
            fi
            
            # Apply exclusion filters first
            if should_exclude "$src" "$dst" "$ip_name_mapping"; then
                continue
            fi
            
            # Apply source/destination filtering at flow level
            if [[ -n "$FILTER_SRC" ]]; then
                # Check if source matches filter (IP, machine name, or partial match)
                local src_matches=false
                local resolved_src_ip=$(resolve_machine_name_to_ip "$FILTER_SRC" "$ip_name_mapping")
                
                if [[ "$src" == *"$FILTER_SRC"* ]] || [[ "$src_ip" == *"$FILTER_SRC"* ]]; then
                    src_matches=true
                elif [[ -n "$resolved_src_ip" ]] && { [[ "$src" == *"$resolved_src_ip"* ]] || [[ "$src_ip" == *"$resolved_src_ip"* ]]; }; then
                    src_matches=true
                fi
                
                if [[ "$src_matches" != "true" ]]; then
                    continue
                fi
            fi
            
            if [[ -n "$FILTER_DST" ]]; then
                # Check if destination matches filter (IP, machine name, or partial match)
                local dst_matches=false
                local resolved_dst_ip=$(resolve_machine_name_to_ip "$FILTER_DST" "$ip_name_mapping")
                
                if [[ "$dst" == *"$FILTER_DST"* ]] || [[ "$dst_ip" == *"$FILTER_DST"* ]]; then
                    dst_matches=true
                elif [[ -n "$resolved_dst_ip" ]] && { [[ "$dst" == *"$resolved_dst_ip"* ]] || [[ "$dst_ip" == *"$resolved_dst_ip"* ]]; }; then
                    dst_matches=true
                fi
                
                if [[ "$dst_matches" != "true" ]]; then
                    continue
                fi
            fi
            
            ((FILTERED_RECORDS++))
            
            # Resolve Tailscale IPs (100.x.x.x) to machine names
            if [[ "$src_ip" =~ ^100\. ]]; then
                resolved_name=$(lookup_machine_name "$src_ip" "$ip_name_mapping")
                if [[ "$resolved_name" != "$src_ip" ]]; then
                    # Truncate long hostnames to fit column (42 chars max + ellipsis if needed)
                    if [[ ${#resolved_name} -gt 42 ]]; then
                        src_ip="${resolved_name:0:39}..."
                    else
                        src_ip="$resolved_name"
                    fi
                fi
            fi
            
            if [[ "$dst_ip" =~ ^100\. ]]; then
                resolved_name=$(lookup_machine_name "$dst_ip" "$ip_name_mapping")
                if [[ "$resolved_name" != "$dst_ip" ]]; then
                    # Truncate long hostnames to fit column (27 chars max + ellipsis if needed)
                    if [[ ${#resolved_name} -gt 42 ]]; then
                        dst_ip="${resolved_name:0:39}..."
                    else
                        dst_ip="$resolved_name"
                    fi
                fi
            fi
            
            # Apply IP masking if requested
            src_ip=$(mask_ip "$src_ip")
            dst_ip=$(mask_ip "$dst_ip")
            
            # Format with proper column alignment and stream output immediately
            printf "%-8s %-43s %-43s %s\n" \
                "$formatted_time" "$src_ip" "$dst_ip" "$type"
            ((line_count++))
        done < <(echo "$response" | jq -r "$jq_filter")
        
        # Add footer header if output is longer than 20 lines  
        if [[ $line_count -gt 20 ]]; then
            echo "--------|-------------------------------------------|-------------------------------------------|--------"
            echo "Time     Src IP                                      Dst IP                                      Type"
        fi
    else
        echo "jq is required for compact formatting. Install jq or use --format json"
        exit 1
    fi
}

format_csv_output() {
    local response="$1"
    local ip_name_mapping="$2"
    if command -v jq >/dev/null 2>&1; then
        # CSV header
        echo "Time,Source IP,Source Port,Destination IP,Destination Port,Type,Protocol,TX Bytes,RX Bytes"
        
        # Check if there are any logs at all
        local log_count=$(echo "$response" | jq -r '.logs | length // 0' 2>/dev/null || echo "0")
        if [[ "$log_count" -eq 0 ]]; then
            return
        fi
        
        # Build the jq filter based on FILTER_TYPE
        local jq_filter='
        .logs[]? // [] | select(.) | 
        . as $log |
        ('
        
        if [[ -n "$FILTER_TYPE" ]]; then
            case "$FILTER_TYPE" in
                "virtual")
                    jq_filter+='
                    if .virtualTraffic then 
                        .virtualTraffic[] | [$log.start, (.src // ""), (.dst // ""), (.proto // ""), (.txBytes // 0), (.rxBytes // 0), "virtual"]
                    else [] end'
                    ;;
                "subnet")
                    jq_filter+='
                    if .subnetTraffic then 
                        .subnetTraffic[] | [$log.start, (.src // ""), (.dst // ""), (.proto // ""), (.txBytes // 0), (.rxBytes // 0), "subnet"]
                    else [] end'
                    ;;
                "exit")
                    jq_filter+='
                    if .exitTraffic then 
                        .exitTraffic[] | [$log.start, (.src // ""), (.dst // ""), (.proto // ""), (.txBytes // 0), (.rxBytes // 0), "exit"]
                    else [] end'
                    ;;
                "physical")
                    jq_filter+='
                    if .physicalTraffic then 
                        .physicalTraffic[] | [$log.start, (.src // ""), (.dst // ""), (.proto // ""), (.txBytes // 0), (.rxBytes // 0), "physical"]
                    else [] end'
                    ;;
            esac
        else
            # No filter - show all traffic types
            jq_filter+='
            if .virtualTraffic then 
                .virtualTraffic[] | [$log.start, (.src // ""), (.dst // ""), (.proto // ""), (.txBytes // 0), (.rxBytes // 0), "virtual"]
            else [] end,
            if .subnetTraffic then 
                .subnetTraffic[] | [$log.start, (.src // ""), (.dst // ""), (.proto // ""), (.txBytes // 0), (.rxBytes // 0), "subnet"]
            else [] end,
            if .exitTraffic then 
                .exitTraffic[] | [$log.start, (.src // ""), (.dst // ""), (.proto // ""), (.txBytes // 0), (.rxBytes // 0), "exit"]
            else [] end,
            if .physicalTraffic then 
                .physicalTraffic[] | [$log.start, (.src // ""), (.dst // ""), (.proto // ""), (.txBytes // 0), (.rxBytes // 0), "physical"]
            else [] end'
        fi
        
        jq_filter+='
        ) | select(length > 0) | @tsv'
        
        # Process all flows and output as CSV
        echo "$response" | jq -r "$jq_filter" | while IFS=$'\t' read -r start src dst proto txBytes rxBytes type; do
            # Format timestamp to local time
            formatted_time=$(format_timestamp "$start")
            
            # Handle empty fields
            [[ "$src" == "null" || -z "$src" ]] && src=""
            [[ "$dst" == "null" || -z "$dst" ]] && dst=""
            [[ "$proto" == "null" || -z "$proto" ]] && proto=""
            [[ "$txBytes" == "null" || -z "$txBytes" ]] && txBytes="0"
            [[ "$rxBytes" == "null" || -z "$rxBytes" ]] && rxBytes="0"
            
            # Split src and dst into IP and port (handle IPv6 [ip]:port format)
            src_ip=""
            src_port=""
            dst_ip=""
            dst_port=""
            
            if [[ -n "$src" ]]; then
                if [[ "$src" =~ ^\[.*\]:[0-9]+$ ]]; then
                    # IPv6 format: [ipv6]:port
                    src_ip="${src%:*}"
                    src_port="${src##*:}"
                elif [[ "$src" =~ ^[^:]*:[0-9]+$ ]]; then
                    # IPv4 format: ipv4:port
                    src_ip="${src%:*}"
                    src_port="${src##*:}"
                else
                    # No port or IPv6 without port
                    src_ip="$src"
                fi
            fi
            
            if [[ -n "$dst" ]]; then
                if [[ "$dst" =~ ^\[.*\]:[0-9]+$ ]]; then
                    # IPv6 format: [ipv6]:port
                    dst_ip="${dst%:*}"
                    dst_port="${dst##*:}"
                elif [[ "$dst" =~ ^[^:]*:[0-9]+$ ]]; then
                    # IPv4 format: ipv4:port
                    dst_ip="${dst%:*}"
                    dst_port="${dst##*:}"
                else
                    # No port or IPv6 without port
                    dst_ip="$dst"
                fi
            fi
            
            # Apply source/destination filtering at flow level
            if [[ -n "$FILTER_SRC" ]]; then
                # Check if source matches filter (IP, machine name, or partial match)
                local src_machine_name=$(lookup_machine_name "$src_ip" "$ip_name_mapping")
                if ! [[ "$src_ip" == *"$FILTER_SRC"* || "$src_machine_name" == *"$FILTER_SRC"* || "$src" == *"$FILTER_SRC"* ]]; then
                    continue
                fi
            fi
            
            if [[ -n "$FILTER_DST" ]]; then
                # Check if destination matches filter (IP, machine name, or partial match)
                local dst_machine_name=$(lookup_machine_name "$dst_ip" "$ip_name_mapping")
                if ! [[ "$dst_ip" == *"$FILTER_DST"* || "$dst_machine_name" == *"$FILTER_DST"* || "$dst" == *"$FILTER_DST"* ]]; then
                    continue
                fi
            fi
            
            # Resolve machine names for Tailscale IPs
            src_display=$(lookup_machine_name "$src_ip" "$ip_name_mapping")
            dst_display=$(lookup_machine_name "$dst_ip" "$ip_name_mapping")
            
            # Get protocol name
            proto_display=$(get_protocol_name "$proto")
            
            # Output CSV row (properly escape fields with commas)
            echo "${formatted_time},${src_display},${src_port},${dst_display},${dst_port},${type},${proto_display},${txBytes},${rxBytes}"
        done
    else
        echo "jq is required for CSV formatting. Install jq or use --format raw"
        exit 1
    fi
}

get_protocol_name() {
    local proto_num="$1"
    if [[ -z "$proto_num" || "$proto_num" == "null" ]]; then
        echo ""
        return
    fi
    case "$proto_num" in
        1) echo "ICMP" ;;
        6) echo "TCP" ;;
        17) echo "UDP" ;;
        47) echo "GRE" ;;
        50) echo "ESP" ;;
        51) echo "AH" ;;
        *) echo "$proto_num" ;;
    esac
}

get_service_name() {
    local port="$1"
    if [[ -z "$port" || "$port" == "null" || "$port" == "0" ]]; then
        echo ""
        return
    fi
    case "$port" in
        20) echo "ftpd" ;;
        21) echo "ftp" ;;
        22) echo "ssh" ;;
        23) echo "telnt" ;;
        25) echo "smtp" ;;
        53) echo "dns" ;;
        67) echo "dhcps" ;;
        68) echo "dhcpc" ;;
        80) echo "http" ;;
        110) echo "pop3" ;;
        123) echo "ntp" ;;
        137) echo "nbns" ;;
        138) echo "nbdgm" ;;
        139) echo "nbssn" ;;
        143) echo "imap" ;;
        161) echo "snmp" ;;
        162) echo "snmpt" ;;
        443) echo "https" ;;
        465) echo "smtps" ;;
        587) echo "subm" ;;
        993) echo "imaps" ;;
        995) echo "pop3s" ;;
        3389) echo "rdp" ;;
        5432) echo "pgsql" ;;
        3306) echo "mysql" ;;
        6379) echo "redis" ;;
        8080) echo "http8" ;;
        9100) echo "prom" ;;
        *) echo "$port" ;;
    esac
}

format_timestamp() {
    local timestamp="$1"
    if [[ -z "$timestamp" || "$timestamp" == "null" ]]; then
        echo ""
        return
    fi
    
    # Remove milliseconds and convert to local time
    local clean_timestamp=$(echo "$timestamp" | sed 's/\.[0-9]*Z$/Z/')
    
    # Convert to local time format (HH:MM:SS)
    if command -v gdate >/dev/null 2>&1; then
        gdate -d "$clean_timestamp" +"%H:%M:%S" 2>/dev/null || echo "$clean_timestamp"
    else
        date -d "$clean_timestamp" +"%H:%M:%S" 2>/dev/null || \
        date -j -f "%Y-%m-%dT%H:%M:%SZ" "$clean_timestamp" +"%H:%M:%S" 2>/dev/null || \
        echo "$clean_timestamp"
    fi
}

format_table_output() {
    local response="$1"
    local ip_name_mapping="$2"
    if command -v jq >/dev/null 2>&1; then
        show_filtering_info "$ip_name_mapping"
        echo "Time     Src IP                                      SPort    Dst IP                                      DPort    Type     Proto TxBytes  RxBytes"
        echo "--------|-------------------------------------------|--------|-------------------------------------------|--------|--------|-----|--------|-------"
        
        # Check if there are any logs at all
        local log_count=$(echo "$response" | jq -r '.logs | length // 0' 2>/dev/null || echo "0")
        if [[ "$log_count" -eq 0 ]]; then
            echo "No logs captured for this time range"
            return
        fi
        
        # Build the jq filter based on FILTER_TYPE
        local jq_filter='
        .logs[]? // [] | select(.) | 
        . as $log |
        ('
        
        if [[ -n "$FILTER_TYPE" ]]; then
            case "$FILTER_TYPE" in
                "virtual")
                    jq_filter+='
                    if .virtualTraffic then 
                        .virtualTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "virtual", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
                    else [] end'
                    ;;
                "subnet")
                    jq_filter+='
                    if .subnetTraffic then 
                        .subnetTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "subnet", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
                    else [] end'
                    ;;
                "exit")
                    jq_filter+='
                    if .exitTraffic then 
                        .exitTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "exit", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
                    else [] end'
                    ;;
                "physical")
                    jq_filter+='
                    if .physicalTraffic then 
                        .physicalTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "physical", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
                    else [] end'
                    ;;
            esac
        else
            # No filter - show all traffic types
            jq_filter+='
            if .virtualTraffic then 
                .virtualTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "virtual", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
            else [] end,
            if .subnetTraffic then 
                .subnetTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "subnet", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
            else [] end,
            if .exitTraffic then 
                .exitTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "exit", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
            else [] end,
            if .physicalTraffic then 
                .physicalTraffic[] | [$log.start, (.src // "NULL"), (.dst // "NULL"), "physical", (.proto // "NULL"), (.txBytes // "NULL"), (.rxBytes // "NULL")]
            else [] end'
        fi
        
        jq_filter+='
        ) | select(length > 0) | @tsv'
        
        # Process all flows and stream output while counting lines
        local line_count=0
        
        while IFS=$'\t' read -r start src dst type proto txBytes rxBytes; do
            # Format timestamp to local time
            formatted_time=$(format_timestamp "$start")
            
            # Handle empty fields - convert NULL placeholders to appropriate defaults
            [[ "$src" == "NULL" || "$src" == "null" || -z "$src" ]] && src=""
            [[ "$dst" == "NULL" || "$dst" == "null" || -z "$dst" ]] && dst=""
            [[ "$proto" == "NULL" || "$proto" == "null" || -z "$proto" ]] && proto=""
            [[ "$txBytes" == "NULL" || "$txBytes" == "null" || -z "$txBytes" ]] && txBytes="0"
            [[ "$rxBytes" == "NULL" || "$rxBytes" == "null" || -z "$rxBytes" ]] && rxBytes="0"
            
            # Split src into IP and port (handle IPv6 [ip]:port format)
            if [[ -n "$src" ]]; then
                if [[ "$src" =~ ^\[.*\]:[0-9]+$ ]]; then
                    # IPv6 format: [ipv6]:port
                    src_ip="${src%:*}"
                    src_port="${src##*:}"
                elif [[ "$src" =~ ^[^:]*:[0-9]+$ ]]; then
                    # IPv4 format: ipv4:port
                    src_ip="${src%:*}"
                    src_port="${src##*:}"
                else
                    # No port or IPv6 without port
                    src_ip="$src"
                    src_port=""
                fi
            else
                src_ip=""
                src_port=""
            fi
            
            # Split dst into IP and port (handle IPv6 [ip]:port format)
            if [[ -n "$dst" ]]; then
                if [[ "$dst" =~ ^\[.*\]:[0-9]+$ ]]; then
                    # IPv6 format: [ipv6]:port
                    dst_ip="${dst%:*}"
                    dst_port="${dst##*:}"
                elif [[ "$dst" =~ ^[^:]*:[0-9]+$ ]]; then
                    # IPv4 format: ipv4:port
                    dst_ip="${dst%:*}"
                    dst_port="${dst##*:}"
                else
                    # No port or IPv6 without port
                    dst_ip="$dst"
                    dst_port=""
                fi
            else
                dst_ip=""
                dst_port=""
            fi
            
            # Apply exclusion filters first
            if should_exclude "$src" "$dst" "$ip_name_mapping"; then
                continue
            fi
            
            # Apply source/destination filtering at flow level
            if [[ -n "$FILTER_SRC" ]]; then
                # Check if source matches filter (IP, machine name, or partial match)
                local src_matches=false
                local resolved_src_ip=$(resolve_machine_name_to_ip "$FILTER_SRC" "$ip_name_mapping")
                
                if [[ "$src" == *"$FILTER_SRC"* ]] || [[ "$src_ip" == *"$FILTER_SRC"* ]]; then
                    src_matches=true
                elif [[ -n "$resolved_src_ip" ]] && { [[ "$src" == *"$resolved_src_ip"* ]] || [[ "$src_ip" == *"$resolved_src_ip"* ]]; }; then
                    src_matches=true
                fi
                
                if [[ "$src_matches" != "true" ]]; then
                    continue
                fi
            fi
            
            if [[ -n "$FILTER_DST" ]]; then
                # Check if destination matches filter (IP, machine name, or partial match)
                local dst_matches=false
                local resolved_dst_ip=$(resolve_machine_name_to_ip "$FILTER_DST" "$ip_name_mapping")
                
                if [[ "$dst" == *"$FILTER_DST"* ]] || [[ "$dst_ip" == *"$FILTER_DST"* ]]; then
                    dst_matches=true
                elif [[ -n "$resolved_dst_ip" ]] && { [[ "$dst" == *"$resolved_dst_ip"* ]] || [[ "$dst_ip" == *"$resolved_dst_ip"* ]]; }; then
                    dst_matches=true
                fi
                
                if [[ "$dst_matches" != "true" ]]; then
                    continue
                fi
            fi
            
            ((FILTERED_RECORDS++))
            
            # Resolve Tailscale IPs (100.x.x.x) to machine names
            if [[ "$src_ip" =~ ^100\. ]]; then
                resolved_name=$(lookup_machine_name "$src_ip" "$ip_name_mapping")
                if [[ "$resolved_name" != "$src_ip" ]]; then
                    # Truncate long hostnames to fit column (42 chars max + ellipsis if needed)
                    if [[ ${#resolved_name} -gt 42 ]]; then
                        src_ip="${resolved_name:0:39}..."
                    else
                        src_ip="$resolved_name"
                    fi
                fi
            fi
            
            if [[ "$dst_ip" =~ ^100\. ]]; then
                resolved_name=$(lookup_machine_name "$dst_ip" "$ip_name_mapping")
                if [[ "$resolved_name" != "$dst_ip" ]]; then
                    # Truncate long hostnames to fit column (27 chars max + ellipsis if needed)
                    if [[ ${#resolved_name} -gt 42 ]]; then
                        dst_ip="${resolved_name:0:39}..."
                    else
                        dst_ip="$resolved_name"
                    fi
                fi
            fi
            
            # Apply IP masking if requested
            src_ip=$(mask_ip "$src_ip")
            dst_ip=$(mask_ip "$dst_ip")
            
            # Convert port numbers to service names
            src_service=$(get_service_name "$src_port")
            dst_service=$(get_service_name "$dst_port")
            
            # Use service names if available, otherwise use port numbers
            [[ -n "$src_service" && "$src_service" != "$src_port" ]] && src_port="$src_service"
            [[ -n "$dst_service" && "$dst_service" != "$dst_port" ]] && dst_port="$dst_service"
            
            # Convert protocol number to name
            proto_name=$(get_protocol_name "$proto")
            
            # Format with proper column alignment and stream output immediately
            printf "%-8s %-43s %-8s %-43s %-8s %-8s %-5s %-8s %s\n" \
                "$formatted_time" "$src_ip" "$src_port" "$dst_ip" "$dst_port" "$type" "$proto_name" "$txBytes" "$rxBytes"
            ((line_count++))
        done < <(echo "$response" | jq -r "$jq_filter")
        
        # Add footer header if output is longer than 20 lines
        if [[ $line_count -gt 20 ]]; then
            echo "--------|-------------------------------------------|--------|-------------------------------------------|--------|--------|-----|--------|-------"
            echo "Time     Src IP                                      SPort    Dst IP                                      DPort    Type     Proto TxBytes  RxBytes"
        fi
    else
        echo "jq is required for table formatting. Install jq or use --format json"
        exit 1
    fi
}

format_bytes() {
    local bytes="$1"
    if [[ -z "$bytes" || "$bytes" == "null" || "$bytes" == "0" ]]; then
        echo "0 B"
        return
    fi
    
    if command -v bc >/dev/null 2>&1; then
        # Use bc for precise decimal arithmetic
        if (( bytes >= 1073741824 )); then
            printf "%.1f GB" "$(echo "scale=1; $bytes / 1073741824" | bc)"
        elif (( bytes >= 1048576 )); then
            printf "%.1f MB" "$(echo "scale=1; $bytes / 1048576" | bc)"
        elif (( bytes >= 1024 )); then
            printf "%.1f KB" "$(echo "scale=1; $bytes / 1024" | bc)"
        else
            printf "%d B" "$bytes"
        fi
    else
        # Fallback to integer arithmetic
        local -i num_bytes=$bytes
        if (( num_bytes >= 1073741824 )); then
            printf "%d GB" "$(( num_bytes / 1073741824 ))"
        elif (( num_bytes >= 1048576 )); then
            printf "%d MB" "$(( num_bytes / 1048576 ))"
        elif (( num_bytes >= 1024 )); then
            printf "%d KB" "$(( num_bytes / 1024 ))"
        else
            printf "%d B" "$num_bytes"
        fi
    fi
}

show_summary() {
    local response="$1"
    local ip_name_mapping="$2"
    if command -v jq >/dev/null 2>&1; then
        local total_logs=$(echo "$response" | jq -r '.logs | length')
        local unique_nodes=$(echo "$response" | jq -r '[.logs[]?.nodeId] | unique | length')
        local traffic_types=$(echo "$response" | jq -r '[.logs[] | keys[] | select(. | contains("Traffic"))] | unique | join(", ")')
        
        echo "=== Traffic Summary ==="
        echo "Total log entries: $total_logs"
        echo "Unique nodes: $unique_nodes"
        echo "Traffic types found: ${traffic_types:-none}"
        echo ""
        
        if [[ $total_logs -gt 0 ]]; then
            # Create comprehensive per-machine statistics using jq to aggregate by resolved machine names
            echo "Machine Activity Summary:"
            printf "%-31s | %7s | %10s | %10s | %7s | %7s | %7s | %8s\n" "Machine Name" "Entries" "TX Bytes" "RX Bytes" "Virtual" "Subnet" "Exit" "Physical"
            printf "%-31s | %7s | %10s | %10s | %7s | %7s | %7s | %8s\n" "-------------------------------" "-------" "----------" "----------" "-------" "-------" "-------" "--------"
            
            # Use jq to create machine summary with aggregation
            echo "$response" | jq -r --arg ip_mapping "$ip_name_mapping" '
                # First, create a lookup function for machine names
                ($ip_mapping | split("\n") | map(select(length > 0) | split(":")) | map({(.[0]): .[1]}) | add) as $machine_lookup |
                
                # Process each log entry to get per-nodeId stats with resolved machine names
                [.logs[] | . as $log | {
                    nodeId: .nodeId,
                    entries: 1,
                    tx_bytes: ((.virtualTraffic[]?.txBytes // 0) + (.exitTraffic[]?.txBytes // 0) + (.subnetTraffic[]?.txBytes // 0) + (.physicalTraffic[]?.txBytes // 0)),
                    rx_bytes: ((.virtualTraffic[]?.rxBytes // 0) + (.exitTraffic[]?.rxBytes // 0) + (.subnetTraffic[]?.rxBytes // 0) + (.physicalTraffic[]?.rxBytes // 0)),
                    has_virtual: ((.virtualTraffic | length) > 0),
                    has_subnet: ((.subnetTraffic | length) > 0), 
                    has_exit: ((.exitTraffic | length) > 0),
                    has_physical: ((.physicalTraffic | length) > 0),
                    # Extract Tailscale IP from traffic for machine name resolution
                    tailscale_ip: ([(.virtualTraffic[]?, .exitTraffic[]?, .subnetTraffic[]?, .physicalTraffic[]?) | [.src, .dst] | .[] | select(. and startswith("100.")) | split(":")[0]] | .[0])
                }] |
                
                # Group by nodeId and aggregate
                group_by(.nodeId) | map({
                    nodeId: .[0].nodeId,
                    entries: (map(.entries) | add),
                    total_tx: (map(.tx_bytes) | add),
                    total_rx: (map(.rx_bytes) | add),
                    has_virtual: (map(.has_virtual) | any),
                    has_subnet: (map(.has_subnet) | any),
                    has_exit: (map(.has_exit) | any),
                    has_physical: (map(.has_physical) | any),
                    tailscale_ip: (map(.tailscale_ip) | map(select(. != null)) | .[0])
                }) |
                
                # Resolve machine names and aggregate by machine name
                map(. + {
                    machine_name: (
                        if .tailscale_ip then
                            ($machine_lookup[.tailscale_ip] // .tailscale_ip | gsub("\\.tail[0-9]+\\.ts\\.net$"; "") | .[0:30])
                        else
                            (.nodeId | .[0:15])
                        end
                    )
                }) |
                
                # Final aggregation by machine name
                group_by(.machine_name) | map({
                    machine_name: .[0].machine_name,
                    entries: (map(.entries) | add),
                    total_tx: (map(.total_tx) | add),
                    total_rx: (map(.total_rx) | add),
                    has_virtual: (map(.has_virtual) | any),
                    has_subnet: (map(.has_subnet) | any),
                    has_exit: (map(.has_exit) | any),
                    has_physical: (map(.has_physical) | any)
                }) |
                
                # Sort by entries count (descending) and output
                sort_by(-.entries)[] |
                
                # Format output
                [
                    .machine_name,
                    (.entries | tostring),
                    (.total_tx | tostring),
                    (.total_rx | tostring),
                    (if .has_virtual then "   ✓   " else "       " end),
                    (if .has_subnet then "   ✓   " else "       " end),
                    (if .has_exit then "   ✓   " else "       " end),
                    (if .has_physical then "   ✓   " else "        " end)
                ] | @tsv
            ' | while IFS=$'\t' read -r machine_name entries total_tx total_rx virtual_ind subnet_ind exit_ind physical_ind; do
                # Format bytes with appropriate units
                local tx_formatted=$(format_bytes "$total_tx")
                local rx_formatted=$(format_bytes "$total_rx")
                
                # Output with proper column alignment  
                printf "%-31s | %7s | %10s | %10s | %7s | %7s | %7s | %8s\n" \
                       "$machine_name" \
                       "$entries" \
                       "$tx_formatted" \
                       "$rx_formatted" \
                       "$virtual_ind" \
                       "$subnet_ind" \
                       "$exit_ind" \
                       "$physical_ind"
            done
            
            echo ""
            echo "Traffic Types:"
            echo "  Virtual  - Direct Tailscale-to-Tailscale communication"
            echo "  Subnet   - Traffic to/from subnet routes"
            echo "  Exit     - Traffic through exit nodes to external internet"  
            echo "  Physical - Underlying physical network communication"
        fi
    else
        echo "jq is required for summary. Install jq or use --format json"
        exit 1
    fi
}

filter_logs() {
    local response="$1"
    local ip_name_mapping="$2"
    local filtered="$response"
    
    if [[ -n "$FILTER_TYPE" ]] && command -v jq >/dev/null 2>&1; then
        filtered=$(echo "$filtered" | jq --arg type "$FILTER_TYPE" '.logs |= map(select(.[$type + "Traffic"] != null))')
    fi
    
    # Source/destination filtering
    if [[ -n "$FILTER_SRC" || -n "$FILTER_DST" ]] && command -v jq >/dev/null 2>&1; then
        local filter_conditions=()
        
        if [[ -n "$FILTER_SRC" ]]; then
            # Try to resolve machine name to IP
            local resolved_ip=$(resolve_machine_name_to_ip "$FILTER_SRC" "$ip_name_mapping")
            
            # Create filter that matches both original filter and resolved IP (if found)
            local src_patterns="\"$FILTER_SRC\""
            if [[ -n "$resolved_ip" ]]; then
                src_patterns+=", \"$resolved_ip\""
            fi
            
            filter_conditions+=("(
                (.virtualTraffic[]? | .src | . as \$src | [$src_patterns] | any(. as \$pattern | \$src | contains(\$pattern))) or
                (.subnetTraffic[]? | .src | . as \$src | [$src_patterns] | any(. as \$pattern | \$src | contains(\$pattern))) or
                (.exitTraffic[]? | .src | . as \$src | [$src_patterns] | any(. as \$pattern | \$src | contains(\$pattern))) or
                (.physicalTraffic[]? | .src | . as \$src | [$src_patterns] | any(. as \$pattern | \$src | contains(\$pattern))) or
                (.nodeId | contains(\"$FILTER_SRC\"))
            )")
        fi
        
        if [[ -n "$FILTER_DST" ]]; then
            # Try to resolve machine name to IP
            local resolved_ip=$(resolve_machine_name_to_ip "$FILTER_DST" "$ip_name_mapping")
            
            # Create filter that matches both original filter and resolved IP (if found)
            local dst_patterns="\"$FILTER_DST\""
            if [[ -n "$resolved_ip" ]]; then
                dst_patterns+=", \"$resolved_ip\""
            fi
            
            filter_conditions+=("(
                (.virtualTraffic[]? | .dst | . as \$dst | [$dst_patterns] | any(. as \$pattern | \$dst | contains(\$pattern))) or
                (.subnetTraffic[]? | .dst | . as \$dst | [$dst_patterns] | any(. as \$pattern | \$dst | contains(\$pattern))) or
                (.exitTraffic[]? | .dst | . as \$dst | [$dst_patterns] | any(. as \$pattern | \$dst | contains(\$pattern))) or
                (.physicalTraffic[]? | .dst | . as \$dst | [$dst_patterns] | any(. as \$pattern | \$dst | contains(\$pattern)))
            )")
        fi
        
        # Combine conditions with AND logic
        local combined_filter
        if [[ ${#filter_conditions[@]} -eq 1 ]]; then
            combined_filter="${filter_conditions[0]}"
        else
            combined_filter=$(printf " and %s" "${filter_conditions[@]}")
            combined_filter="${combined_filter:5}" # Remove leading " and "
        fi
        
        filtered=$(echo "$filtered" | jq ".logs |= map(select($combined_filter))")
    fi
    
    echo "$filtered"
}

fetch_devices() {
    local api_token
    api_token=$(get_api_token)
    
    local url="https://api.tailscale.com/api/v2/tailnet/${TAILNET}/devices"
    
    debug_log "Fetching device info from: $url"
    echo "Fetching device information..." >&2
    
    # Track device fetch time
    local fetch_start
    if command -v gdate >/dev/null 2>&1; then
        fetch_start=$(gdate +%s%3N)
    else
        fetch_start=$(($(date +%s) * 1000))
    fi
    
    local response
    response=$(curl -s -u "$api_token:" "$url")
    local curl_exit=$?
    
    local fetch_end
    if command -v gdate >/dev/null 2>&1; then
        fetch_end=$(gdate +%s%3N)
    else
        fetch_end=$(($(date +%s) * 1000))
    fi
    DEVICE_FETCH_TIME=$((fetch_end - fetch_start))
    debug_log "Device fetch completed in ${DEVICE_FETCH_TIME}ms"
    
    if [[ $curl_exit -ne 0 ]]; then
        echo "Error: Failed to fetch devices from Tailscale API (curl exit code: $curl_exit)" >&2
        exit 1
    fi
    
    if echo "$response" | grep -q '"error"'; then
        echo "Error from Tailscale API:" >&2
        echo "$response" >&2
        exit 1
    fi
    
    # Count devices if in debug mode
    if [[ "$DEBUG_MODE" == true ]] && command -v jq >/dev/null 2>&1; then
        local device_count=$(echo "$response" | jq '.devices | length // 0' 2>/dev/null || echo "0")
        debug_log "Total devices fetched: $device_count"
    fi
    
    echo "$response"
}

create_ip_name_mapping() {
    local devices_response="$1"
    if command -v jq >/dev/null 2>&1; then
        echo "$devices_response" | jq -r '.devices[] | "\(.addresses[0] // "unknown") \(.name // .hostname // "unknown")"' | \
        while read -r ip name; do
            echo "$ip:$name"
        done
    fi
}

lookup_machine_name() {
    local ip="$1"
    local mapping="$2"
    
    local name=$(echo "$mapping" | grep "^$ip:" | cut -d: -f2-)
    if [[ -n "$name" && "$name" != "unknown" ]]; then
        # Strip the tailnet suffix (e.g., .tail43508.ts.net)
        echo "$name" | sed 's/\.tail[0-9]*\.ts\.net$//'
    else
        echo "$ip"
    fi
}

resolve_machine_name_to_ip() {
    local machine_name="$1"
    local mapping="$2"
    
    # Strip potential tailnet suffix from input for matching
    local clean_name=$(echo "$machine_name" | sed 's/\.tail[0-9]*\.ts\.net$//')
    
    # Look for the machine name in the mapping and return the IP
    local ip=$(echo "$mapping" | grep ":.*$clean_name" | head -1 | cut -d: -f1)
    if [[ -n "$ip" ]]; then
        echo "$ip"
    else
        # Return empty if not found
        echo ""
    fi
}

show_filtering_info() {
    local ip_name_mapping="$1"
    
    if [[ -n "$FILTER_SRC" || -n "$FILTER_DST" ]]; then
        echo "# Filtering criteria:"
        
        if [[ -n "$FILTER_SRC" ]]; then
            local resolved_src_ip=$(resolve_machine_name_to_ip "$FILTER_SRC" "$ip_name_mapping")
            local src_criteria="source matching '$FILTER_SRC'"
            
            if [[ -n "$resolved_src_ip" ]]; then
                src_criteria+=", '${resolved_src_ip}', or partial matches"
            else
                src_criteria+=", IP addresses, or partial matches"
            fi
            
            echo "# - Showing flows with $src_criteria"
        fi
        
        if [[ -n "$FILTER_DST" ]]; then
            local resolved_dst_ip=$(resolve_machine_name_to_ip "$FILTER_DST" "$ip_name_mapping")
            local dst_criteria="destination matching '$FILTER_DST'"
            
            if [[ -n "$resolved_dst_ip" ]]; then
                dst_criteria+=", '${resolved_dst_ip}', or partial matches"
            else
                dst_criteria+=", IP addresses, or partial matches"
            fi
            
            echo "# - Showing flows with $dst_criteria"
        fi
        
        echo "#"
    fi
}


fetch_logs() {
    local api_token
    api_token=$(get_api_token)
    
    local url="https://api.tailscale.com/api/v2/tailnet/${TAILNET}/logging/network?start=${START_TIME}&end=${END_TIME}"
    
    debug_log "API URL: $url"
    echo "Fetching logs from $START_TIME to $END_TIME..." >&2
    
    # Track API fetch time
    local fetch_start
    if command -v gdate >/dev/null 2>&1; then
        fetch_start=$(gdate +%s%3N)
    else
        fetch_start=$(($(date +%s) * 1000))
    fi
    
    local response
    response=$(curl -s -u "$api_token:" "$url")
    local curl_exit=$?
    
    local fetch_end
    if command -v gdate >/dev/null 2>&1; then
        fetch_end=$(gdate +%s%3N)
    else
        fetch_end=$(($(date +%s) * 1000))
    fi
    API_FETCH_TIME=$((fetch_end - fetch_start))
    debug_log "API fetch completed in ${API_FETCH_TIME}ms"
    
    if [[ $curl_exit -ne 0 ]]; then
        echo "Error: Failed to fetch logs from Tailscale API (curl exit code: $curl_exit)" >&2
        exit 1
    fi
    
    if echo "$response" | grep -q '"error"'; then
        echo "Error from Tailscale API:" >&2
        echo "$response" >&2
        exit 1
    fi
    
    # Count total records
    if command -v jq >/dev/null 2>&1; then
        TOTAL_RECORDS=$(echo "$response" | jq '.logs | length // 0' 2>/dev/null || echo "0")
        debug_log "Total records fetched: $TOTAL_RECORDS"
    fi
    
    echo "$response"
}

main() {
    local show_summary=false
    local hours=""
    local days=""
    local minutes=""
    local since=""
    local until=""
    local today=false
    local yesterday=false
    
    # If no arguments provided, show help
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_help
                exit 0
                ;;
            --format|-f)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --format requires a value (table, compact, csv, json, or raw)" >&2
                    exit 1
                fi
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            --filter-type|-t)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --filter-type requires a value (virtual, subnet, exit, or physical)" >&2
                    exit 1
                fi
                case "$2" in
                    virtual|subnet|exit|physical)
                        FILTER_TYPE="$2"
                        ;;
                    table|json|raw|compact)
                        echo "Error: '$2' is an output format, not a traffic type." >&2
                        echo "Use: -f $2 (for format) instead of -t $2" >&2
                        echo "Valid traffic types for -t: virtual, subnet, exit, physical" >&2
                        exit 1
                        ;;
                    *)
                        echo "Error: Invalid traffic type '$2'" >&2
                        echo "Valid traffic types: virtual, subnet, exit, physical" >&2
                        exit 1
                        ;;
                esac
                shift 2
                ;;
            --src|-S)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --src requires a value (machine name, IP, or node ID)" >&2
                    exit 1
                fi
                FILTER_SRC="$2"
                shift 2
                ;;
            --dst|-D)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --dst requires a value (machine name, IP, or node ID)" >&2
                    exit 1
                fi
                FILTER_DST="$2"
                shift 2
                ;;
            --tailnet|-T)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --tailnet requires a value" >&2
                    exit 1
                fi
                TAILNET="$2"
                shift 2
                ;;
            --summary|-s)
                show_summary=true
                shift
                ;;
            --hours|-H)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --hours requires a numeric value" >&2
                    exit 1
                fi
                hours="$2"
                validate_numeric "$hours" "--hours"
                shift 2
                ;;
            --days|-d)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --days requires a numeric value" >&2
                    exit 1
                fi
                days="$2"
                validate_numeric "$days" "--days"
                shift 2
                ;;
            --minutes|-m)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --minutes requires a numeric value" >&2
                    exit 1
                fi
                minutes="$2"
                validate_numeric "$minutes" "--minutes"
                shift 2
                ;;
            --since)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --since requires a timestamp value" >&2
                    exit 1
                fi
                since="$2"
                shift 2
                ;;
            --until)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --until requires a timestamp value" >&2
                    exit 1
                fi
                until="$2"
                shift 2
                ;;
            --today)
                today=true
                shift
                ;;
            --yesterday)
                yesterday=true
                shift
                ;;
            --debug)
                DEBUG_MODE=true
                shift
                ;;
            --stats)
                SHOW_STATS=true
                shift
                ;;
            --mask-ips)
                MASK_IPS=true
                shift
                ;;
            --exclude-src)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --exclude-src requires a value (machine name, IP, or node ID)" >&2
                    exit 1
                fi
                EXCLUDE_SRC="$2"
                shift 2
                ;;
            --exclude-dst)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --exclude-dst requires a value (machine name, IP, or node ID)" >&2
                    exit 1
                fi
                EXCLUDE_DST="$2"
                shift 2
                ;;
            *)
                echo "Error: Unknown option $1" >&2
                show_help >&2
                exit 1
                ;;
        esac
    done
    
    # Check configuration before proceeding
    check_configuration
    
    # Record processing start time
    if command -v gdate >/dev/null 2>&1; then
        PROCESSING_START_TIME=$(gdate +%s%3N)
    else
        PROCESSING_START_TIME=$(($(date +%s) * 1000))
    fi
    debug_log "Processing started at $PROCESSING_START_TIME"
    
    # Set time range based on parsed arguments
    if [[ -n "$minutes" ]]; then
        if command -v gdate >/dev/null 2>&1; then
            START_TIME=$(gdate -u -d "$minutes minutes ago" --iso-8601=seconds | sed 's/+00:00/Z/')
            END_TIME=$(gdate -u --iso-8601=seconds | sed 's/+00:00/Z/')
        else
            START_TIME=$(date -u -d "$minutes minutes ago" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-"${minutes}"M +"%Y-%m-%dT%H:%M:%SZ")
            END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        fi
    elif [[ -n "$hours" ]]; then
        if command -v gdate >/dev/null 2>&1; then
            START_TIME=$(gdate -u -d "$hours hours ago" --iso-8601=seconds | sed 's/+00:00/Z/')
            END_TIME=$(gdate -u --iso-8601=seconds | sed 's/+00:00/Z/')
        else
            START_TIME=$(date -u -d "$hours hours ago" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-"${hours}"H +"%Y-%m-%dT%H:%M:%SZ")
            END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        fi
    elif [[ -n "$days" ]]; then
        if command -v gdate >/dev/null 2>&1; then
            START_TIME=$(gdate -u -d "$days days ago" --iso-8601=seconds | sed 's/+00:00/Z/')
            END_TIME=$(gdate -u --iso-8601=seconds | sed 's/+00:00/Z/')
        else
            START_TIME=$(date -u -d "$days days ago" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-"${days}"d +"%Y-%m-%dT%H:%M:%SZ")
            END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        fi
    elif [[ "$today" == true ]]; then
        if command -v gdate >/dev/null 2>&1; then
            START_TIME=$(gdate -u -d "today 00:00:00" --iso-8601=seconds | sed 's/+00:00/Z/')
            END_TIME=$(gdate -u --iso-8601=seconds | sed 's/+00:00/Z/')
        else
            START_TIME=$(date -u -d "today 00:00:00" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u +"%Y-%m-%dT00:00:00Z")
            END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        fi
    elif [[ "$yesterday" == true ]]; then
        if command -v gdate >/dev/null 2>&1; then
            START_TIME=$(gdate -u -d "yesterday 00:00:00" --iso-8601=seconds | sed 's/+00:00/Z/')
            END_TIME=$(gdate -u -d "yesterday 23:59:59" --iso-8601=seconds | sed 's/+00:00/Z/')
        else
            START_TIME=$(date -u -d "yesterday 00:00:00" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-1d +"%Y-%m-%dT00:00:00Z")
            END_TIME=$(date -u -d "yesterday 23:59:59" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-1d +"%Y-%m-%dT23:59:59Z")
        fi
    elif [[ -n "$since" ]]; then
        validate_date "$since"
        START_TIME="$since"
        if [[ -n "$until" ]]; then
            validate_date "$until"
            END_TIME="$until"
        else
            if command -v gdate >/dev/null 2>&1; then
                END_TIME=$(gdate -u --iso-8601=seconds | sed 's/+00:00/Z/')
            else
                END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            fi
        fi
    else
        echo "Error: You must specify a time range option (--minutes, --hours, --days, --today, --yesterday, or --since)" >&2
        show_help >&2
        exit 1
    fi
    
    if [[ "$OUTPUT_FORMAT" != "json" && "$OUTPUT_FORMAT" != "table" && "$OUTPUT_FORMAT" != "raw" && "$OUTPUT_FORMAT" != "compact" && "$OUTPUT_FORMAT" != "csv" ]]; then
        echo "Error: Invalid output format. Use: json, table, raw, compact, or csv" >&2
        exit 1
    fi
    
    # Fetch device information for machine name mapping (needed for table/compact/csv formats, summary, and src/dst filtering)
    local ip_name_mapping=""
    if [[ "$OUTPUT_FORMAT" == "table" || "$OUTPUT_FORMAT" == "compact" || "$OUTPUT_FORMAT" == "csv" || "$show_summary" == true || -n "$FILTER_SRC" || -n "$FILTER_DST" ]]; then
        local devices_response
        devices_response=$(fetch_devices)
        ip_name_mapping=$(create_ip_name_mapping "$devices_response")
    fi
    
    local response
    response=$(fetch_logs)
    
    local filtered_response
    # Apply filtering for formats that don't handle it internally - table and compact handle flow-level filtering internally
    # Summary also needs pre-filtered data when using src/dst filters
    if [[ ( "$OUTPUT_FORMAT" != "table" && "$OUTPUT_FORMAT" != "compact" && ( -n "$FILTER_SRC" || -n "$FILTER_DST" || -n "$FILTER_TYPE" ) ) || 
          ( "$show_summary" == true && ( -n "$FILTER_SRC" || -n "$FILTER_DST" ) ) ]]; then
        filtered_response=$(filter_logs "$response" "$ip_name_mapping")
    else
        filtered_response="$response"
    fi
    
    # Record processing end time before output
    if command -v gdate >/dev/null 2>&1; then
        PROCESSING_END_TIME=$(gdate +%s%3N)
    else
        PROCESSING_END_TIME=$(($(date +%s) * 1000))
    fi
    debug_log "Processing ended at $PROCESSING_END_TIME"
    
    if [[ "$show_summary" == true ]]; then
        show_summary "$filtered_response" "$ip_name_mapping"
    elif [[ "$OUTPUT_FORMAT" == "table" ]]; then
        format_table_output "$filtered_response" "$ip_name_mapping"
    elif [[ "$OUTPUT_FORMAT" == "compact" ]]; then
        format_compact_output "$filtered_response" "$ip_name_mapping"
    elif [[ "$OUTPUT_FORMAT" == "csv" ]]; then
        format_csv_output "$filtered_response" "$ip_name_mapping"
    elif [[ "$OUTPUT_FORMAT" == "json" ]]; then
        format_json_output "$filtered_response"
    else
        echo "$filtered_response"
    fi
    
    # Show statistics if requested
    if [[ "$SHOW_STATS" == true ]]; then
        show_statistics
    fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
